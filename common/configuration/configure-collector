eval '(exit $?0)' && eval 'exec perl -w -S $0 ${1+"$@"}'
                  && eval 'exec perl -w -S $0 $argv:q'
                  if 0;

########################################################################
########################################################################

use strict;

use Getopt::Long;
use File::Basename;
use File::Path;
use Pod::Usage;

my $gratia_dir;
if (-l $0) {
  $gratia_dir = dirname(readlink($0));
} else {
  $gratia_dir = dirname $0;
}

my %collector_configs = ();

my @required_attributes =
  (
   'http_port',
   'ssl_port',
   'rmi_port',
   'jmx_port',
   'db_schema',
   'UserConfig',
   'sslCAFiles',
   'crlFiles',
   'staticReports'
  );

my @required_properties = ();

my %attribute_defaults =
  (
   max_heap_size => "256m",
   db_port => 3320,
   db_host => "gratia-db01.fnal.gov",
   UserConfig => "UserConfig_osg.xml",
   UserConfigPath => "gratia-reports/MenuConfig/",
   PostInstallCmdPreamble => "",
   PostInstallCmdPrefix => "",
   PostInstallCmdSuffix => "",
   staticReports => 1,
   host_cert => "/etc/grid-security/hostcert.pem",
   host_key => "/etc/grid-security/hostkey.pem",
   sslCAFiles => "/etc/grid-security/certificates/*.0",
   crlFiles => "/etc/grid-security/certificates/*.r0",
   service_auto_start => 1,
   "properties.attributes" =>
   { "service.rmi.service" => "/gratia",
     "use.report.authentication" => "true",
     "maintain.history.log" => 14,
     "service.mysql.user" => "gratia",
     "service.mysql.password" => "proto",
     "service.reporting.user" => "reader", # new
     "service.reporting.password" => "reader", # new
     "monitor.listener.threads" => "true",
     "monitor.listener.wait" => 240,
     "monitor.smtp.server" => "smtp.fnal.gov",
     "monitor.smtp.authentication.required" => "false",
     "monitor.smtp.user" => "greenc",
     "monitor.smtp.password" => "",
     "monitor.from.address" => 'grid-accounting@fnal.gov',
     "monitor.to.address.0" => 'pcanal@fnal.gov',
     "monitor.to.address.1" => 'greenc@fnal.gov',
     "monitor.subject" => \&construct_monitor_message_subject,
     "service.rmiservlet.console" => 0,
     "service.security.console" => 0,
     "service.vdt.cert.file" => "/etc/grid-security/http/httpcert.pem",
     "service.vdt.key.file" => "/etc/grid-security/http/httpkey.pem",
     "service.listener.threads" => 1,
     "service.lifetime.JobUsageRecord" => "1 year", # May wish to dencrease
     "service.lifetime.JobUsageRecord.RawXML" => "1 month",
     "service.lifetime.MetricRecord" => "3 months", # Shouldn't get these at all
     "service.lifetime.MetricRecord.RawXML" => "1 month",
     "service.lifetime.DupRecord.Duplicate" => "1 month",
     "service.lifetime.DupRecord.ExpirationDate" => "1 month",
     "service.lifetime.DupRecord" => "UNLIMITED",
     "service.lifetime.Trace" => "6 months",
     "service.lifetime.Trace.add_JUR_to_summary" => "3 months"
   }
  );

my $tomcat_users_txt = <<'EOF';
<?xml version='1.0' encoding='utf-8'?>
<tomcat-users>
  <role rolename="tomcat"/>
  <role rolename="role1"/>
  <role rolename="manager"/>
  <role rolename="admin"/>
  <user username="penelope" password="vdt-gratia" fullName="Penelope Constanta" roles="admin,manager"/>
  <user username="gratia" password="proto" fullName="gratia prototype user" roles="admin,manager"/>
  <user username="root" password="lisp01" roles="admin,manager"/>
</tomcat-users>
EOF

my $init_script_template = <<'EOF';
#!/bin/bash
#
# tomcat-<instance>     Start and stop an instance of the standalone tomcat service.
#
# chkconfig: 345 99 50
# description: Standalone tomcat invocation for the Gratia service

####################################
# Ensure these variables are set as appropriate
JAVA_HOME=
TOMCAT_HTTP_PORT=
TOMCAT_PATH_STEM=
TOMCAT_SSL_PORT=
TOMCAT_USER=
####################################
export JAVA_HOME

PATH="${PATH}:${JAVA_HOME}/bin" # Needed for SSL keytool

# This should be fine as a default
TOMCAT_INSTANCE_NAME=`basename "$0" | sed -e 's/^.*\(tomcat-.*\)$/\1/'`

########################################################################
# No User Servicable Parts
CATALINA_HOME="${TOMCAT_PATH_STEM}/${TOMCAT_INSTANCE_NAME}"; export CATALINA_HOME

[[ -n "${KRB5CCNAME}" ]] && KRB5CCNAME=`echo "${KRB5CCNAME}" | sed -e 's/^FILE://'`

function start {
  JAVA_OPTS="-server -Dcom.sun.management.jmxremote -Dssl.port=${TOMCAT_SSL_PORT} -Dcom.mchange.v2.c3p0.management.ManagementCoordinator=com.mchange.v2.c3p0.management.NullManagementCoordinator"; export JAVA_OPTS
  if [[ -n "${TOMCAT_USER}" ]]; then
    su -c "${CATALINA_HOME}/bin/catalina.sh start" ${TOMCAT_USER}
  else
    $CATALINA_HOME/bin/catalina.sh start
  fi
}

function stop {
  # wget --no-check-certificate --certificate="^^^HOST_CERT^^^" --private-key="^^^HOST_KEY^^^" --dns-timeout=5 --connect-timeout=10 --read-timeout=20 -O - -q '^^^STOP_DB_UPDATE_URL^^^' >/dev/null 2>&1
  if [[ -n "${TOMCAT_USER}" ]]; then
    su -c "${CATALINA_HOME}/bin/shutdown.sh" ${TOMCAT_USER}
  else
    ${CATALINA_HOME}/bin/shutdown.sh
  fi
}

function is_running {
  local process_cnt="$(ps -ef | grep -E -e "file=$TOMCAT_PATH_STEM/$TOMCAT_INSTANCE_NAME" | grep -E -e '  1 ' | grep -E -v grep | wc -l)"
  local result
  case $process_cnt in
    0) result=1
       ;;
    1) result=0
       ;;
    *) result=2
       ;;
  esac
  return $result
}

if [ "$1" = "start" ] ; then
  start
elif [ "$1" = "stop" ] ; then
  stop
elif [ "$1" = "restart" ]; then
  if is_running; then
    stop
    echo "Pause ..."
    sleep 20
    start
  else
    echo "${TOMCAT_INSTANCE_NAME} does not appear to be running: not attempting to restart"
    exit 1
  fi
else
  echo "Usage: ${TOMCAT_INSTANCE_NAME} [start | stop | restart]"
  exit 1
fi
EOF

my %options = ();

my $default_java_home = "/scratch/java";
my $default_remote_host = `uname -n`;
chomp $default_remote_host;
my $default_prefix = "/scratch";

my @default_collector_info =
  ( "collector-pro.dat",
    "collector-itb.dat",
    "collector-dev.dat" );

Getopt::Long::Configure(qw(no_ignore_case bundling require_order));

GetOptions(\%options, "java-home|j=s",
           "remote-host|r=s",
           "use-ssl|s",
           "prefix|p=s",
           "db-root|d=s",
           "collector-info|c=s@",
           "obtain-config-item=s@",
           "obtain-properties-item=s@",
           "help|h|\?") or pod2usage(-exitval => 2);

pod2usage(-exitval => 1, -verbose => 3) if $options{help};

unless (exists $options{"java-home"} or
        exists $options{"obtain-config-item"} or
        exists $options{"obtain-properties-item"}) {
  if (-d $default_java_home) {
    print STDERR "INFO: using default JAVA_HOME $default_java_home\n";
    $options{"java-home"} = $default_java_home;
  } else {
    print STDERR "ERROR: JAVA_HOME not specified and default \"$default_java_home\" does not exist as a directory\n";
    pod2usage(-exitval => 1);
  }
}

unless (exists $options{prefix}) {
  if (-d $default_prefix and -w $default_prefix) {
    print STDERR "INFO: tomcat install prefix not specified, ",
      "using default $default_prefix\n";
    $options{prefix} = $default_prefix;
  } else {
    print STDERR "ERROR: tomcat install prefix not specified ",
      "and default \"$default_prefix\"",
        "\ndoes not exist as a directory or is not writable\"";
    pod2usage(-exitval => 1);
  }
}               

pod2usage(-exitval => 1) unless scalar @ARGV;

my @instance_list = @ARGV;

unless (exists $options{"collector-info"} and scalar @{$options{"collector-info"}}) {
  $options{"collector-info"} = [ @default_collector_info ];
}


foreach my $config (@instance_list) {
  foreach my $dat_file (@{$options{"collector-info"}}) {
    $dat_file = find_dat_file($dat_file, "$options{prefix}/tomcat-${config}/gratia");
    if (not open(DAT_SOURCE, $dat_file)) {
      print STDERR "ERROR: Unable to open data file $dat_file\n";
      next;
    }
    my $dat_source = join('', <DAT_SOURCE>);
    close DAT_SOURCE;
    my %tmp_hash = eval $dat_source;
    if ($@) {
      print STDERR "ERROR: Problem reading collector data file $dat_file\n";
      next;
    }
    if (exists $tmp_hash{$config}) {
      $collector_configs{$config} = $tmp_hash{$config};
      print STDERR "INFO: found configuration for instance, \"$config\" in $dat_file\n";
      last;
    }
  }

  my $config_ref = $collector_configs{$config};

  if (not $config_ref) {
    print STDERR "WARNING: configuration for specified gratia instance $config not found!\n";
    exit 1;
  }

  # attributes.properties container if not previously existing.
  $config_ref->{"properties.attributes"} = {}
    unless exists $config_ref->{"properties.attributes"};

  # Standard attribute defaults.
  my $specified_addresses = grep m&monitor\.to\.address&o, keys %{$config_ref->{"properties.attributes"}};
  foreach my $attribute_key (sort keys %attribute_defaults) {
    $config_ref->{$attribute_key} = $attribute_defaults{$attribute_key}
      unless exists $config_ref->{$attribute_key};
  }

  # Properties attribute defaults.
  foreach my $properties_key (sort keys %{$attribute_defaults{"properties.attributes"}}) {
    # Skip all default email addresses if we specified any at all.
    next if $specified_addresses and $properties_key =~ m&monitor\.to\.address&o;
    $config_ref->{"properties.attributes"}->{$properties_key} =
      $attribute_defaults{"properties.attributes"}->{$properties_key}
        unless exists $config_ref->{"properties.attributes"}->{$properties_key};
  }

  # Required attributes
  my $requirements_error = 0;
  foreach my $required_attribute (@required_attributes) {
    unless (exists $config_ref->{$required_attribute}) {
      print STDERR "Configuration for instance \"$config\" does not have ",
        "required attribute \"$required_attribute\"\n";
      $requirements_error = 1;
    }
  }

  foreach my $required_attribute (@required_properties) {
    unless (exists $config_ref->{"properties.attributes"}->{$required_attribute}) {
      print STDERR "Configuration for instance \"$config\" does not have ",
        "required properties.attributes entry \"$required_attribute\"\n";
      $requirements_error = 1;
    }
  }

  # Next if failed requirements.
  next if $requirements_error;

  # Maybe print requested config information and exit
  maybe_print_config_info($config, $config_ref) and exit(1);

  # Check and (maybe) override remote_host setting
  verify_remote_host_setting($config, $config_ref);

  # Configuration operations.
  configure_keyfile_owners($config, $config_ref);
  configure_collector_config($config, $config_ref);
  configure_init_file($config, $config_ref);
  configure_tomcat_config($config, $config_ref);
  configure_tomcat_users($config, $config_ref);
  # configure_log4j_properties($config, $config_ref) if $options{"use-ssl"};
  configure_static_report_generation($config, $config_ref);

  if (exists $options{"db-root"}) {
    configure_post_install($config, $config_ref);
  } else {
    print STDERR "WARNING: no DB root password specified: post-install.sh not configured\n";
  }

  if ($config_ref->{"no_collector"}) {
    foreach my $war qw(services soap servlets administration) {
      system("rm -rf $options{prefix}/tomcat-${config}/webapps/gratia-$war\{,.war\}");
    }
  }

  configure_installation_owner($config, $config_ref);

}

1;

#--------------------------------------
sub configure_apel_directory {
  my ($instance_name, $collector_config) = @_;
  my $type = "APEL interfaces folder -";
  print STDERR "INFO: $type starting\n"; 
  my $apel       = $collector_config->{"properties.attributes"}->{"service.reporting.interfaces.apel.folder"};
  my $apel_group = $collector_config->{"properties.attributes"}->{"service.reporting.interfaces.apel.folder.groupowner"};
  unless ( defined $apel ) {
    print STDERR "INFO: $type not required.\n";
    print STDERR "INFO: $type complete\n"; 
    return 1;
  }
  unless ( defined $apel_group ) {
    print  STDERR "ERROR: $type requested but no service.reporting.interfaces.apel.folder.groupowner specified.\n";
    exit 1;
  }
  my $data_directory = "$options{prefix}/tomcat-${instance_name}/webapps/$apel";
  if ( -d $data_directory ) { 
    print STDERR "INFO: $type already exists - $data_directory \n"; 
  } else {
    print STDERR "INFO: $type creating directory - $data_directory\n";
    eval ( mkpath($data_directory) );
    if ($@) {
      print  STDERR "ERROR: $type Failed to make directory - $data_directory\n"; exit 1;
    }
  }
  my $owner = $collector_config->{tomcat_user};
  unless ( defined $owner ) {
    $owner = getlogin();
  }
  print STDERR "INFO: $type setting ownership($owner.$apel_group)/permissions(0775)\n";
  chmod 0775, $data_directory;
  my $uid = getpwnam($owner);
  my $gid = getgrnam($apel_group);
  unless ( defined $uid ) {
    print  STDERR "ERROR: $type owner ($owner) not in /etc/passwd file\n";exit 1;
  } 
  unless ( defined $gid ) {
    print  STDERR "ERROR: $type group ($apel_group) not in /etc/group file\n";exit 1;
  } 
  chown $uid,$gid, $data_directory;
  print STDERR "INFO: $type complete\n"; 
}

#--------------------------------------
sub configure_log4j_properties {
  return unless $options{"use-ssl"};
  my ($instance_name, $collector_config) = @_;
  my $log4j_prop = ">$options{prefix}/tomcat-${instance_name}/conf/log4j-trustmanager.properties";
  open(LOG4J_PROP, $log4j_prop) or die "Unable to open $log4j_prop for writing";
  print LOG4J_PROP <<'EOF';
log4j.logger.org.glite.security=INFO, fileout

log4j.appender.fileout=org.apache.log4j.RollingFileAppender

# the OUTPUT FILE for the logging messages
log4j.appender.fileout.File=${catalina.base}/logs/glite-security-trustmanager.log

# define max file size for the debug file
log4j.appender.fileout.MaxFileSize=100KB

# Keep one backup file
log4j.appender.fileout.MaxBackupIndex=1

log4j.appender.fileout.layout=org.apache.log4j.PatternLayout
# define the pattern of the messages
log4j.appender.fileout.layout.ConversionPattern=%d{ISO8601} %-5p [%t] %c{2} %x - %m%n
# this also outputs the method name, but is very slow
#log4j.appender.fileout.layout.ConversionPattern=%d{ISO8601} %-5p [%t] %c{2} %M %x - %m%n
EOF
  close(LOG4J_PROP);
}

  sub configure_post_install {
    my ($instance_name, $collector_config) = @_;
    my $post_file = "$options{prefix}/tomcat-${instance_name}/gratia/post-install.sh";
    my $new_post = temporary_filename("post-install.sh");
    open(ORIG_POST, "<$post_file") or die "Unable to open $post_file for reading";
    open(NEW_POST, ">$new_post") or die "Unable to open $new_post for writing";
    chmod 0700, $new_post;
    $collector_config->{"PostInstallCmdPreamble"} =~
      s&DB_HOST&$collector_config->{"db_host"}&g
        if $collector_config->{"PostInstallCmdPrefix"};
    $collector_config->{"PostInstallCmdPrefix"} =~
      s&DB_HOST&$collector_config->{"db_host"}&g
        if $collector_config->{"PostInstallCmdPrefix"};
    while (<ORIG_POST>) {
      chomp;
      s&\${VDT_LOCATION}/mysql5/bin/&&; # VDT-specific location.
      s&\${VDT_LOCATION}/tomcat/v55/gratia/&$options{prefix}/tomcat-${instance_name}/gratia/&; # VDT-specific location.
      s&CMD_PREAMBLE&$collector_config->{"PostInstallCmdPreamble"}&;
      s&localhost&$collector_config->{"db_host"}&;
      s&(^.*?mysql.*?)CMD_SUFFIX(.*$)&$1$collector_config->{"PostInstallCmdSuffix"}$2&;
      s&(^.*?mysql.*?)ROOTPASS(.*$)&$1"$options{"db-root"}"$2&; # DB root password
      s&(^.*?mysql.*?)PORT(.*$)&$1$collector_config->{db_port}$2&; # DB port
      s&(^.*?mysql.*?) gratia (.*$)&$1 $collector_config->{db_schema} $2&; # Schema
      s&(^.*?)MAGIC_VDT_LOCATION/tomcat/v55/(.*$)&$1$options{prefix}/tomcat-${instance_name}/$2&; # Tomcat top dir
      # Extra commands to prefix mysql command (eg ssh, echo);
      s&^(.*?)CMD_PREFIX(.*$)&$1$collector_config->{"PostInstallCmdPrefix"}$2&;
      print NEW_POST "$_\n";
    }
    close(ORIG_POST);
    close(NEW_POST);
    system("mv -bv \"$new_post\" \"$post_file\"");
  }

sub configure_init_file {
  my ($instance_name, $collector_config) = @_;
  my $stop_db_update_url =
    sprintf("%s%s:%s/gratia-administration/systemadministration.html?action=stopDatabaseUpdateThreads",
            $options{"use-ssl"}?"https://":"http://",
            $collector_config->{collector_host},
            $options{"use-ssl"}?$collector_config->{ssl_port}:$collector_config->{http_port});
  my $init_script = "/etc/rc.d/init.d/tomcat-$instance_name";
  my $init_script_txt = $init_script_template;
  $init_script_txt =~ s&^(\s*JAVA_OPTS\s*=\s*".*?)"&${1} -Xmx$collector_config->{max_heap_size}"&m if $collector_config->{max_heap_size};
  $init_script_txt =~ s&^(\s*JAVA_OPTS\s*=\s*".*?)"&${1} -Xms$collector_config->{initial_heap_size}"&m if $collector_config->{inital_heap_size};
  $init_script_txt =~ s&^(\s*JAVA_OPTS\s*=\s*".*?)"&${1} -XX:MaxPermSize=$collector_config->{max_perm_size}"&m if $collector_config->{max_perm_size};
  $init_script_txt =~ s&^(\s*JAVA_OPTS\s*=\s*".*?)"&${1} -XX:PermSize=$collector_config->{initial_perm_size}"&m if $collector_config->{initial_perm_size};
  $init_script_txt =~ s&^(\s*JAVA_OPTS\s*=\s*".*?)"&${1} -Djava.library.path=$collector_config->{tomcat_native_lib}"&m if $collector_config->{tomcat_native_lib};
  $init_script_txt =~ s&^(JAVA_HOME=).*$&${1}"$options{"java-home"}"&m;
  $init_script_txt =~ s&^(TOMCAT_HTTP_PORT=).*$&${1}$collector_config->{http_port}&m;
  $init_script_txt =~ s&^(TOMCAT_PATH_STEM=).*$&${1}"$options{prefix}"&m;
  $init_script_txt =~ s&^(TOMCAT_SSL_PORT=).*$&${1}$collector_config->{ssl_port}&m;
  $init_script_txt =~
    s&^(TOMCAT_USER=).*$&${1}$collector_config->{tomcat_user}&m
      if $collector_config->{tomcat_user};
  $init_script_txt =~ s&\^\^\^STOP_DB_UPDATE_URL\^\^\^&$stop_db_update_url&;
  $init_script_txt =~ s&\^\^\^HOST_CERT\^\^\^&$collector_config->{host_cert}&;
  $init_script_txt =~ s&\^\^\^HOST_KEY\^\^\^&$collector_config->{host_key}&;
  open(INIT_SCRIPT, ">$init_script") or die("Unable to open $init_script for writing");
  print INIT_SCRIPT $init_script_txt;
  close(INIT_SCRIPT);
  chmod 0755, $init_script;
  if ($collector_config->{service_auto_start}) {
    system("/sbin/chkconfig --add tomcat-$instance_name");
  } else { # De-activate.
    system("/sbin/chkconfig --del tomcat-$instance_name");
  }
}

sub configure_collector_config {
  my ($instance_name, $collector_config) = @_;
  my $orig_config = "$options{prefix}/tomcat-${instance_name}/gratia/service-configuration.properties";
  my $config_file = temporary_filename("service-configuration.properties");
  open(ORIG_CONFIG, "<$orig_config") or die "Unable to open $orig_config for reading";
  open(REPORTING_CONFIG, ">$config_file") or die "Unable to open $config_file for writing";
  chmod 0600, $config_file;
  my %seen_attributes = ();
  my $in_summary_comment;
  my $spaced_rmi_port = sprintf("%5d", $collector_config->{rmi_port});
  my $spaced_http_port = sprintf("%5d", $collector_config->{http_port});
  my $spaced_ssl_port = sprintf("%5d", $collector_config->{ssl_port});
  my $spaced_jmx_port = sprintf("%5d", $collector_config->{jmx_port});
  my $spaced_db_port = sprintf("%5d", $collector_config->{db_port});

  foreach my $config_attribute (sort keys %{$collector_config->{"properties.attributes"}}) {
    # Code substitutions
    if (ref($collector_config->{"properties.attributes"}->{$config_attribute}) eq "CODE") {
      $collector_config->{"properties.attributes"}->{$config_attribute} =
        $collector_config->{"properties.attributes"}->{$config_attribute}($instance_name, $collector_config);
    }
  }

  # Compound attributes and those using common attributes (eg http_port).
  $collector_config->{"properties.attributes"}->{"service.reporting.menuconfig"} =
    "$collector_config->{UserConfigPath}$collector_config->{UserConfig}";
  $collector_config->{"properties.attributes"}->{"service.rmi.port"} =
    "$collector_config->{rmi_port}";
  $collector_config->{"properties.attributes"}->{"service.rmi.rmibind"} =
    "//$collector_config->{collector_host}:$collector_config->{rmi_port}";
  $collector_config->{"properties.attributes"}->{"service.rmi.rmilookup"} =
    "rmi://$collector_config->{collector_host}:$collector_config->{rmi_port}";
  $collector_config->{"properties.attributes"}->{"service.open.connection"} =
    "http://$collector_config->{collector_host}:$collector_config->{http_port}"
      unless exists $collector_config->{"properties.attributes"}->{"service.open.connection"};
  $collector_config->{"properties.attributes"}->{"service.secure.connection"} =
    "https://$collector_config->{collector_host}:$collector_config->{ssl_port}"
      unless exists $collector_config->{"properties.attributes"}->{"service.secure.connection"};
  $collector_config->{"properties.attributes"}->{"service.mysql.url"} =
    "jdbc:mysql://$collector_config->{db_host}:$collector_config->{db_port}/$collector_config->{db_schema}";

  while (<ORIG_CONFIG>) {
    chomp;
    # Settings summary comment at top of file.
    m&^\s*#\s*default ports used by& and $in_summary_comment = 1;
    if ($in_summary_comment) {
      m&^\s*[^#]& and undef $in_summary_comment;
      s&^(\s*#\s)\s*\d*\s*(->\s*rmi)&${1}$spaced_rmi_port ${2}&;
      s&^(\s*#\s)\s*\d*\s*(->\s*tomcat)&${1}$spaced_http_port ${2}&;
      s&^(\s*#\s)\s*\d*\s*(->\s*tomcat-ssl)&${1}$spaced_ssl_port ${2}&;
      s&^(\s*#\s)\s*\d*\s*(->\s*mysql)&${1}$spaced_db_port ${2}&;
      s&^(\s*#\s)\s*\d*\s*(->\s*tomcat/jmx)&${1}$spaced_jmx_port ${2}&;
    }

    # Simple attributes
    foreach my $config_attribute (sort keys %{$collector_config->{"properties.attributes"}}) {
      $config_attribute =~ m/\.\d+$/ and next; # Special numbered item
        s&^(?:\s*###\s*)?(\Q$config_attribute\E\s*=\s*).*$&${1}$collector_config->{"properties.attributes"}->{$config_attribute}& and
          $seen_attributes{$config_attribute} = 1;
    }

    # Special case for multi-value configuration options -- group
    # similar numbered items together and dump items not wanted from the
    # config.
    if (m&^\s*(###\s*)?((\Qmonitor.to.address\E|\Qservice.admin.DN\E|\Qservice.admin.FQAN\E)\.\d+)&) {
      my ($prefix, $property, $base) = ($1 || '', $2, $3);
      next if ($seen_attributes{$base}); # Only print one set.
      $seen_attributes{$base} = 1;
      foreach my $numbered_attribute (sort(grep /^$base/,
                                           keys %{$collector_config->{"properties.attributes"}})) {
        next if $seen_attributes{$numbered_attribute};
        my $new_line = sprintf("$numbered_attribute = %s\n",
                               $collector_config->{"properties.attributes"}->{$numbered_attribute});
        # print "$_ -> ", $new_line;
        print REPORTING_CONFIG $new_line;
        $seen_attributes{$numbered_attribute} = 1;
      }
      next; # Don't print the line that triggered it.
    }
    print REPORTING_CONFIG "$_\n";
  }
  close(ORIG_CONFIG);
  # Simple attributes which may not already have been in the configuration file (eg monitor.to.address.N)

  foreach my $config_attribute (sort keys %{$collector_config->{"properties.attributes"}}) {
    print REPORTING_CONFIG "$config_attribute=",
      $collector_config->{"properties.attributes"}->{$config_attribute}, "\n"
        unless $seen_attributes{$config_attribute};
  }
  close(REPORTING_CONFIG);
  system("mv -bv \"$config_file\" \"$orig_config\"");
}

sub configure_keyfile_owners {
  my ($instance_name, $collector_config) = @_;
  configure_host_keyfile_owner($instance_name, $collector_config);
  configure_http_keyfile_owner($instance_name, $collector_config);
}

sub configure_host_keyfile_owner {
  my ($instance_name, $collector_config) = @_;
  return unless exists $collector_config->{"host_key"};
  configure_keyfile_owner($instance_name, $collector_config,
                          "configuration attribute host_key",
                          \$collector_config->{"host_key"});
}

sub configure_http_keyfile_owner {
  my ($instance_name, $collector_config) = @_;
  return unless exists $collector_config->{"properties.attributes"}->{"service.vdt.key.file"};
  configure_keyfile_owner($instance_name, $collector_config,
                          "service-configuration.properties attribute service.vdt.key.file",
                          \$collector_config->{"properties.attributes"}->{"service.vdt.key.file"});
}

sub configure_keyfile_owner {
  my ($instance_name, $collector_config, $key_message, $key_ref) = @_;
  if (exists $collector_config->{"tomcat_user"}) {
    if ($$key_ref and -e $$key_ref) {
      print STDERR "TOMCAT_USER specified as ",
        $collector_config->{"tomcat_user"},
          ": verifying readable copy of key at $$key_ref for $key_message ...\n";
      my (@temp) = stat($$key_ref);
      @temp = getpwuid($temp[4]);
      my $user = $temp[0];
      print STDERR "DEBUG: Extracted user name $user as owner of $$key_ref\n";
      if ($user ne
          $collector_config->{"tomcat_user"}) {
        print STDERR "Producing copy of key file readable by $$key_ref ...\n";
        my ($path, $basename, $ext) = ($$key_ref =~ m&^(.*/)?([^\.]*)(.*)$&);
        $path = "" unless defined $path;
        $basename = "" unless defined $basename;
        $ext = "" unless defined $ext;
        print STDERR "DEBUG: deconstructed $$key_ref to ($path, $basename, $ext).\n";
        $basename = "$basename-$collector_config->{\"tomcat_user\"}";
        my $orig_key = $$key_ref;
        $$key_ref = "$path$basename$ext";
        if (system("install -o $collector_config->{\"tomcat_user\"} -m 600 \"$orig_key\" \"$$key_ref\"") == 0) {
          print STDERR "Successfully copied \"$orig_key\" to \"$$key_ref\"\n";
        } else {
          print STDERR "ERROR: could not create copy of key readable by ",
            "$collector_config->{\"tomcat_user\"} as $$key_ref -- you will need to do this ",
              "manually to match the personalized configuration\n";
        }
      }
    } else {
      print STDERR "Key not specified or does not point to real file!\n";
    }
  }
}

sub configure_installation_owner {
  my ($instance_name, $collector_config) = @_;
  if (exists $collector_config->{"tomcat_user"}) {
    print STDERR "TOMCAT_USER specified as ",
      $collector_config->{"tomcat_user"},
        ": changing ownership of $options{prefix}/tomcat-${instance_name} ... ";
    my $group = ($collector_config->{"tomcat_group"})?sprintf(".%s", $collector_config->{"tomcat_group"}):"";
    my $status =
      system("chown -R $collector_config->{\"tomcat_user\"}${group} \"$options{prefix}/tomcat-${instance_name}\"");
    if ($status == 0) {
      print STDERR "OK\n";
      system("chmod g+s \"$options{prefix}/tomcat-${instance_name}\"") if ${group};
    } else {
      print STDERR "FAILED!\n";
      print STDERR "ERROR changing ownership of ",
        "\"$options{prefix}/tomcat-${instance_name}\" ",
          "to $collector_config->{\"tomcat_user\"}${group}\n";
    }
  }
  # Configure ownership of the APEL interface directory.
  configure_apel_directory($instance_name, $collector_config);
}

sub configure_tomcat_config {
  my ($instance_name, $collector_config) = @_;
  my $orig_config = "$options{prefix}/tomcat-${instance_name}/conf/server.xml";
  my $config_file = temporary_filename("server.xml");
  open(ORIG_CONFIG, "<$orig_config") or die "Unable to open $orig_config for reading";
  open(REPORTING_CONFIG, ">$config_file") or die "Unable to open $config_file for writing";
  chmod 0600, $config_file;
  my %seen_attributes = ();
  my $line_buffer = "";
  my $in_comment;
  my $in_catalina;
  my $in_connector;
  while (<ORIG_CONFIG>) {
    next if m&<!-- Gratia connectors -->&; # Avoid comment build-up, floss regularly.
    $line_buffer = "${line_buffer}$_";
    $in_comment = 1 if (m&<!--&);
    if ($line_buffer =~ m&-->&) {
      undef $in_comment;
    }

    next if $in_comment;

    $line_buffer =~ s&(<Server\s*port\s*=\s*)"[^"]+"&${1}"$collector_config->{server_port}"&;

    $line_buffer =~ m&<\s*Service\s*name\s*=\s*"Catalina"\s*>\s*$& and $in_catalina = 1;

    if ($in_catalina and not $in_comment) {
      $line_buffer =~ m&^\s*<\s*Connector\s*& and $in_connector = 1;
      if ($in_connector) {
        next unless $line_buffer =~ m&/\s*>&;
        undef $in_connector;
        $line_buffer =~ s&<\s*Connector.*\s*/\s*>(?:\s*$)?&&s;
      }
      if ($line_buffer =~ m&^\s*<\s*Engine&) {
        print REPORTING_CONFIG <<EOF;
    <!-- Gratia connectors -->
    <Connector port="$collector_config->{http_port}" maxHttpHeaderSize="8192"
               maxThreads="150" minSpareThreads="25" maxSpareThreads="75"
               enableLookups="false" redirectPort="$collector_config->{ssl_port}" acceptCount="100"
               connectionTimeout="20000" disableUploadTimeout="true" />
EOF
        print REPORTING_CONFIG <<EOF if $options{"use-ssl"};
    <Connector port="$collector_config->{ssl_port}"
               maxHttpHeaderSize="8192"
               maxThreads="150"
               minSpareThreads="25"
               maxSpareThreads="75"
               enableLookups="false"
               disableUploadTimeout="true"
               acceptCount="100"
               debug="0"
               scheme="https"
               secure="true"
               sSLImplementation="org.glite.security.trustmanager.tomcat.TMSSLImplementation"
               sslCAFiles="$collector_config->{sslCAFiles}"
               crlFiles="$collector_config->{crlFiles}"
               sslCertFile="$collector_config->{host_cert}"
               sslKey="$collector_config->{host_key}"
               clientAuth="true"
               sslProtocol="TLS"
               crlEnabled="true"
               crlRequired="false"/>
EOF
        #               keystoreFile="$options{prefix}/tomcat-${instance_name}/gratia/keystore" keystorePass="server"
        #               truststoreFile="$options{prefix}/tomcat-${instance_name}/gratia/truststore" truststorePass="server"
        #               log4jConfFile="$options{prefix}/tomcat-${instance_name}/conf/log4j-trustmanager.properties"

      }
    }
    print REPORTING_CONFIG "$line_buffer";
    $line_buffer = "";
  }
  close(ORIG_CONFIG);
  close(REPORTING_CONFIG);
  system("mv -bv \"$config_file\" \"$orig_config\"");
}

sub configure_tomcat_users {
  my ($instance_name, $collector_config) = @_;
  my $config_file = "$options{prefix}/tomcat-${instance_name}/conf/tomcat-users.xml";
  open(CONFIG_SCRIPT, ">$config_file") or die("Unable to open $config_file for writing");
  chmod 0600, $config_file;
  print CONFIG_SCRIPT $tomcat_users_txt;
  close(CONFIG_SCRIPT);
}

sub construct_monitor_message_subject {
  my ($instance_name, $collector_config) = @_;
  return sprintf("%s:%s %s Potential listener problem",
                 $collector_config->{remote_host},
                 $collector_config->{http_port},
                 "tomcat-$instance_name"
                );
}

sub temporary_filename {
  my $stem = shift;
  my $tmp_file=`mktemp "\${TMPDIR:-/tmp}/${stem}_XXXXXXXXXX\"`;
  chomp $tmp_file;
  $tmp_file or die "Unable to create temporary file from stem $stem";
  return $tmp_file;
}

sub configure_static_report_generation {
  my ($instance_name, $collector_config) = @_;
  my $wantStatic =
    ($collector_config->{staticReports} =~ /(?:t|true|1)/i);
  my $removeOrTime = ($wantStatic)?
    "CRON_TIMING=\"42 0 * * *\"":
      "CRON_REMOVE=1";
  my $static_report_generator = "$options{prefix}/tomcat-${instance_name}/gratia/staticReports.py";
  return unless (-x $static_report_generator);
  my @script_pars = ("$options{prefix}/tomcat-${instance_name}",
                     sprintf("%s%s:%s/gratia-reporting/",
                             "http://",
                             $collector_config->{remote_host},
                             $collector_config->{http_port}));
  print STDERR "INFO: ",
    ($wantStatic?
     "configuring static reports":
     "removing any existing static report generation"),
       "\n";
  system(sprintf("VISUAL=${gratia_dir}/safe-replace-crontab $removeOrTime CRON_CMD=\"'$static_report_generator' %s >/dev/null 2>&1\" crontab -e",
                 join(" ", map { "'$_'"; } @script_pars)));
}

sub verify_remote_host_setting {
  my ($instance_name, $collector_config) = @_;
  my $remote_host;
  if ($options{"remote-host"}) {
    print STDERR "INFO: overriding instance-specified remote hostname with command-line-specified $options{\"remote-host\"}\n";
    $remote_host = $options{"remote-host"};
  } elsif ($collector_config->{remote_host}) {
    print STDERR "INFO: using instance-specified remote hostname ",
      $collector_config->{remote_host}, "\n";
    $remote_host = $collector_config->{remote_host};
  } else {
    print STDERR "INFO: using default remote hostname $default_remote_host";
    $remote_host = $default_remote_host;
  }
  # Propagate back for consistency
  $collector_config->{remote_host} = $remote_host;
  $collector_config->{collector_host} =
    ( $collector_config->{remote_host} || "localhost" )
      unless exists $collector_config->{collector_host};
}

sub maybe_print_config_info {
  my ($instance_name, $collector_config) = @_;
  my $printed_info = 0;
  if ($options{"obtain-config-item"} and scalar @{$options{"obtain-config-item"}}) {
    foreach my $item (@{$options{"obtain-config-item"}}) {
      if (exists ($collector_config->{$item})) {
        ++$printed_info;
        print "config: ",
          $item,
            " = ",
              $collector_config->{$item},
                "\n";
      }
    }
  }
  if ($options{"obtain-properties-item"} and scalar @{$options{"obtain-properties-item"}}) {
    foreach my $item (@{$options{"obtain-properties-item"}}) {
      if (exists ($collector_config->{"properties.attributes"}->{$item})) {
        ++$printed_info;
        print "property: ",
          $item,
            " = ",
              $collector_config->{"properties.attributes"}->{$item},
                "\n";
      }
    }
  }
  return $printed_info;
}


use File::Find;
my (@found_files, $list_file);
sub wanted {
  #  print STDERR "File::Find: dir = $File::Find::dir\n";
  if ($File::Find::name =~ m&gratia/data/(?:history-|old-|thread)&) {
    #    print STDERR "File::Find: pruning search tree\n";
    $File::Find::prune = 1;
    return;
  }
  if (-d $_) {
    #    print STDERR "File::Find: looking in $File::Find::name ...\n";
    if (-f "$_/$list_file") {
      push @found_files, "$File::Find::name/$list_file";
      $File::Find::prune = 1;
    } elsif (-f "$_/$list_file.dat") { # Default extension
      push @found_files, "$File::Find::name/$list_file.dat";
      $File::Find::prune = 1;
    }
  }
}

sub find_dat_file {
  $list_file = shift;
  @found_files = ();
  my @search_path = ( "$gratia_dir", @_ );
  chomp $list_file;
  unless ( -f $list_file ) {
    my @dir_list = map { (-d)?$_:() } @search_path;
    #    print STDERR "Looking for $list_file, dir list = ", join(", ", @dir_list), "\n";
    find ( \&wanted, @dir_list );
    # First found in search path order.
    $list_file = $found_files[0] if scalar @found_files;
  }
  return $list_file;
}

__END__
########################################################################
# Plain old documentation
########################################################################

=pod

=head1 NAME

configure-collector: Configure a Gratia / Tomcat instance.

=head1 SYNOPSIS

B<configure-collector> B<-h> | B<--help> | B<-?>

B<configure-collector> [I<global-options>] [--] I<instance>+

I<global-options>: B<-r> I<collector-host-name> | B<--remote-host> I<collector-host-name> |
                 B<-j> I<JRE-home-dir> | B<--java-home> I<JRE-home-dir> |
                 B<-p> I<install-path-prefix> | B<--prefix> I<install-path-prefix> |
                 B<--db-root> |
                 B<--use-ssl> | B<-s>

Options marked with B<+> are repeatable and cumulative.

=head1 DESCRIPTION

I<configure-collector> is a tool to configure one or more gratia instances.

I<configure-collector> can only configure instances about which it
already knows: please look at the B<%collector_configs> associative
array for details.

=head2 OPTIONS

=over 4

=item B<-r> I<collector-host-name>

=item B<--remote-host> I<collector-host-name>


The remote hostname of the collector (eg gratia-osg.fnal.gov).


=item B<-j> I<JRE-home-dir>

=item B<--java-home> I<JRE-home-dir>


The location of a Java-1.5 runtime.


=item B<-p> I<install-path-prefix>

=item B<--prefix> I<install-path-prefix>


The directory above the tomcat instance (eg /scratch).


=item B<--db-root> I<db-root-pword>


The DB (not system) root password.


=item B<-s>

=item B<--use-ssl>


Configure tomcat to open the SSL port (default is yes).

=item B<--obtain-config-item> I<config-item>


Print the specified configuration item to be used for the chosen
instance. Does not continue with the install.


=item B<--obtain-properties-item> I<properties-item>


Print the specified service-configuration.properties item to be used for
the chosen instance. Does not continue with the install.


=head1 AUTHOR

Chris Green <greenc@fnal.gov>.

=cut

### Local Variables:
### mode: cperl
### End:
