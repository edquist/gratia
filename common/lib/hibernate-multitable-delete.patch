Index: core/src/main/java/org/hibernate/dialect/Dialect.java
===================================================================
--- core/src/main/java/org/hibernate/dialect/Dialect.java	(revision 18452)
+++ core/src/main/java/org/hibernate/dialect/Dialect.java	(working copy)
@@ -1824,4 +1824,16 @@
 	public boolean supportsBindAsCallableArgument() {
 		return true;
 	}
+
+   /**
+    * Does this dialect support delete statement syntax like :
+    *   DELETE FROM tbl_name[.*] [, tbl_name[.*]] ...
+    *   USING table_references
+    *   [WHERE where_condition]
+    *
+    * @return True if the database supports the multiple table delete syntax ; false otherwise.
+    */
+    public boolean supportsMultipleTableDelete() {
+       return false;
+    }
 }
Index: core/src/main/java/org/hibernate/dialect/MySQLDialect.java
===================================================================
--- core/src/main/java/org/hibernate/dialect/MySQLDialect.java	(revision 18452)
+++ core/src/main/java/org/hibernate/dialect/MySQLDialect.java	(working copy)
@@ -344,4 +344,8 @@
 	public boolean supportsSubqueryOnMutatingTable() {
 		return false;
 	}
+   
+   public boolean supportsMultipleTableDelete() {
+      return true;
+   }
 }
\ No newline at end of file
Index: core/src/main/java/org/hibernate/hql/ast/exec/MultiTableDeleteExecutor.java
===================================================================
--- core/src/main/java/org/hibernate/hql/ast/exec/MultiTableDeleteExecutor.java	(revision 18452)
+++ core/src/main/java/org/hibernate/hql/ast/exec/MultiTableDeleteExecutor.java	(working copy)
@@ -72,25 +72,59 @@
 
 		String[] tableNames = persister.getConstraintOrderedTableNameClosure();
 		String[][] columnNames = persister.getContraintOrderedTableKeyColumnClosure();
-		String idSubselect = generateIdSubselect( persister );
+		
+      deletes = new String[tableNames.length];
 
-		deletes = new String[tableNames.length];
-		for ( int i = tableNames.length - 1; i >= 0; i-- ) {
-			// TODO : an optimization here would be to consider cascade deletes and not gen those delete statements;
-			//      the difficulty is the ordering of the tables here vs the cascade attributes on the persisters ->
-			//          the table info gotten here should really be self-contained (i.e., a class representation
-			//          defining all the needed attributes), then we could then get an array of those
-			final Delete delete = new Delete()
-					.setTableName( tableNames[i] )
-					.setWhere( "(" + StringHelper.join( ", ", columnNames[i] ) + ") IN (" + idSubselect + ")" );
-			if ( getFactory().getSettings().isCommentsEnabled() ) {
-				delete.setComment( "bulk delete" );
-			}
+      if ( !walker.getSessionFactoryHelper().getFactory().getDialect().supportsMultipleTableDelete() ) {
+         String idSubselect = generateIdSubselect( persister );
 
-			deletes[i] = delete.toStatementString();
-		}
-	}
+         for ( int i = tableNames.length - 1; i >= 0; i-- ) {
+            // TODO : an optimization here would be to consider cascade deletes and not gen those delete statements;
+            //      the difficulty is the ordering of the tables here vs the cascade attributes on the persisters ->
+            //          the table info gotten here should really be self-contained (i.e., a class representation
+            //          defining all the needed attributes), then we could then get an array of those
+            final Delete delete = new Delete()
+               .setTableName( tableNames[i] )
+               .setWhere( "(" + StringHelper.join( ", ", columnNames[i] ) + ") IN (" + idSubselect + ")" );
+            if ( getFactory().getSettings().isCommentsEnabled() ) {
+               delete.setComment( "bulk delete" );
+            }
 
+            deletes[i] = delete.toStatementString();
+         }
+      } else {
+         for ( int i = tableNames.length - 1; i >= 0; i-- ) {
+            // MySQL is bad at executing where (dbid) in (select ...)
+            // so instead we use 'delete from table using table inner join tmptable where table.dbid = tmptable.dbid;' 
+            
+            final Delete delete = new Delete();
+            delete.setTableName( tableNames[i] + " using " +  tableNames[i] + " inner join " +  persister.getTemporaryIdTableName() );
+               
+            int length = columnNames[i].length;
+            if ( length != 0 ) {
+               StringBuffer buf = new StringBuffer( length * columnNames[i][0].length() * 2);
+                  
+               buf.append( tableNames[i] ).append(".").append( columnNames[i][0] );
+               buf.append( " = " );
+               buf.append( persister.getTemporaryIdTableName() ).append(".").append(persister.getIdentifierColumnNames()[0] );
+                  
+               for ( int k = 1; k < length; k++ ) {
+                  buf.append( " and " );
+                  buf.append( tableNames[i] ).append(".").append( columnNames[i][k] );
+                  buf.append( " = " );
+                  buf.append( persister.getTemporaryIdTableName() ).append(".").append(persister.getIdentifierColumnNames()[k] );
+               }
+               delete.setWhere(buf.toString());
+               // .setWhere( StringHelper.join( " and ", StringHelper.add( tableNames[i] + "." + columnNames[i] , " = " , persister.getTemporaryIdTableName() + "." + persister.getIdentifierColumnNames() ) ) );
+            }
+            if ( getFactory().getSettings().isCommentsEnabled() ) {
+               delete.setComment( "bulk delete" );
+            }
+            deletes[i] = delete.toStatementString();
+         }
+      }
+   }
+
 	public String[] getSqlStatements() {
 		return deletes;
 	}
