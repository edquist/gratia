eval '(exit $?0)' && eval 'exec perl -w -S $0 ${1+"$@"}'
                  && eval 'exec perl -w -S $0 $argv:q'
                  if 0;

use strict;

use Getopt::Long;
use File::Basename;
use Pod::Usage;

my %options = ();

my %mysql_options =
(
 "-v" => undef,
 "--force" => undef,
 "-unbuffered" => undef,
 "--user" => "root",
 "--password" => "",
 "--host" => "localhost",
 "--port" => 3320
);

my %procedures =
(
 DailyJobsByFacility => { select_columns => 'CETable.facility_name, ProbeSummary.EndTime as endtime, sum(ProbeSummary.Njobs) as Njobs',
													from_tables => 'CETable,CEProbes,ProbeSummary',
													main_where => 'CEProbes.facility_id = CETable.facility_id and ProbeSummary.ProbeName = CEProbes.probename',
													group_by => 'ProbeSummary.EndTime, CETable.facility_name',
													order_by => 'ProbeSummary.EndTime'
												},
 DailyJobsByProbe => { select_columns => 'ProbeName, ProbeSummary.EndTime as endtime, sum(ProbeSummary.Njobs) as Njobs',
											 from_tables => 'ProbeSummary',
											 main_where => '',
											 group_by => 'ProbeSummary.EndTime, ProbeName',
											 order_by => 'ProbeSummary.EndTime'
										 },
 DailyJobsByVO => { select_columns => 'VOProbeSummary.VOName,VOProbeSummary.EndTime as endtime,sum(Njobs) as Njobs',
										from_tables => 'VOProbeSummary',
										main_where => '',
										group_by => 'VOProbeSummary.EndTime,VOName',
										order_by => 'VOProbeSummary.EndTime'
									},
 DailyUsageByFacility => { select_columns => 'CETable.facility_name,ProbeSummary.EndTime as endtime,sum(ProbeSummary.WallDuration',
													 from_tables => 'CETable,CEProbes,ProbeSummary',
													 main_where => 'CEProbes.facility_id = CETable.facility_id and ProbeSummary.ProbeName = CEProbes.probename',
													 group_by => 'ProbeSummary.EndTime,CETable.facility_name',
													 order_by => 'ProbeSummary.EndTime'
												 },
 DailyUsageByProbe => { select_columns => 'ProbeSummary.ProbeName,ProbeSummary.EndTime',
												from_tables => 'ProbeSummary',
												main_where => '',
												group_by => 'ProbeSummary.EndTime,ProbeSummary.ProbeName',
												order_by => 'ProbeSummary.EndTime'
											},
 JobsByFacility => { select_columns => 'CETable.facility_name,sum(ProbeSummary.Njobs) as Njobs',
										 from_tables => 'CETable,CEProbes,ProbeSummary',
										 main_where => '',
										 group_by => 'CETable.facility_name',
										 order_by => 'CETable.facility_name'
									 },
 JobsByProbeNoFacility => { select_columns => 'ProbeSummary.ProbeName,sum(ProbeSummary.Njobs) as Njobs',
														from_tables => 'ProbeSummary',
														main_where => '',
														group_by => 'ProbeName',
														order_by => 'ProbeName'
													},
 UsageByFacility => { select_columns => 'CETable.facility_name,ProbeSummary.EndTime as endtime,sum(ProbeSummary.WallDuration) as WallDuration',
											from_tables => 'CETable,CEProbes,ProbeSummary',
											main_where => 'CEProbes.facility_id = CETable.facility_id and ProbeSummary.ProbeName = CEProbes.probename',
											group_by => 'CETable.facility_name',
											order_by => 'CETable.facility_name'
										},
 UsageByProbe => { select_columns => 'ProbeSummary.ProbeName,sum(ProbeSummary.WallDuration) as WallDuration',
									 from_tables => 'ProbeSummary',
									 main_where => '',
									 group_by => 'ProbeSummary.ProbeName',
									 order_by => 'ProbeSummary.ProbeName'
								 },
 DailyUsageBySite => { select_columns => 'ProbeSummary.SiteName,ProbeSummary.EndTime as endtime,sum(ProbeSummary.WallDuration) as WallDuration,sum(ProbeSummary.CpuUserDuration + ProbeSummary.CpuSystemDuration) as Cpu',
											 from_tables => 'ProbeSummary',
											 main_where => '',
											 group_by => 'ProbeSummary.ProbeName',
											 order_by => 'ProbeSummary.ProbeName'
										 },
 UsageBySite => { select_columns => 'ProbeSummary.SiteName,sum(ProbeSummary.WallDuration) as WallDuration',
									from_tables => 'ProbeSummary',
									main_where => '',
									group_by => 'ProbeSummary.SiteName',
									order_by => 'ProbeSummary.SiteName'
								},
 JobsBySite => { select_columns => 'ProbeSummary.SiteName,sum(ProbeSummary.Njobs) as Njobs',
								 from_tables => 'ProbeSummary',
								 main_where => '',
								 group_by => 'ProbeSummary.SiteName',
								 order_by => 'ProbeSummary.SiteName'
							 },
 DailyUsageByVO => { select_columns => 'VOProbeSummary.VOName,VOProbeSummary.EndTime as endtime, sum(VOProbeSummary.WallDuration) as WallDuration,sum(VOProbeSummary.CpuUserDuration + VOProbeSummary.CpuSystemDuration) as Cpu',
										 from_tables => 'VOProbeSummary',
										 main_where => '',
										 group_by => 'VOProbeSummary.EndTime',
										 order_by => 'VOProbeSummary.EndTime'
									 },
 UsageByVO => { select_columns => 'VOProbeSummary.VOName,sum(VOProbeSummary.WallDuration) as WallDuration,sum(VOProbeSummary.CpuUserDuration + VOProbeSummary.CpuSystemDuration) as Cpu',
								from_tables => 'VOProbeSummary',
								main_where => '',
								group_by => 'VOProbeSummary.VOName',
								order_by => 'VOProbeSummary.VOName'
							},
 JobsByVO => { select_columns => 'VOProbeSummary.VOName,sum(VOProbeSummary.Njobs) as Njobs',
							 from_tables => 'VOProbeSummary',
							 main_where => '',
							 group_by => 'VOProbeSummary.VOName',
							 order_by => 'VOProbeSummary.VOName'
						 },
 newProcedure => { select_columns => '',
									 from_tables => '',
									 main_where => '',
									 group_by => '',
									 order_by => ''
								 }
);

my @databases = qw(gratia gratia_itb gratia_psacct gratia_qcd gratia_osg_daily);

Getopt::Long::Configure(qw(no_ignore_case bundling require_order));

GetOptions(\%options, "debug|d", , "trace|t", "help|h|\?") or pod2usage(-exitval => 2);

$options{debug} = 1;
# $options{trace} = 1;

if ($options{debug}) {
	my $sql_script = generate_sql();
	process_trace_directives(\$sql_script,$options{trace});
	print $sql_script;
	exit 0;
} else {
	#mysql_connect();
	foreach my $database (@databases) {
		# set database $database
		# execute generate_sql();
	}
}

1;

use FileHandle;
use IPC::Open2;
sub process_trace_directives {
	my ($script_ref,$trace_opt) = @_;
	return if $trace_opt; # trace inserts stay in
	my $pid = open2(\*Reader, \*Writer, "cat -u");
	print Writer $$script_ref;
	close Writer;
	my $input_buffer = "";
	my $in_stmt;
	my $output_buffer;
	while (<Reader>) {
		$input_buffer = "$input_buffer$_";
		chomp;
		if ((not $in_stmt) and m&^\s*(?:#|--|$)&) {
			$output_buffer = "$output_buffer$input_buffer";
			$input_buffer = "";
			next;
		} elsif (m&(?:;|\|\|)\s*(?:#.*)?$&
						or m&\b(?:then|else)\s*(?:#.*)?$&i) {
			if (not ($input_buffer =~ m&insert\s*into\s*trace&m)) {
				$output_buffer = "$output_buffer$input_buffer";
			}
			undef $in_stmt;
			$input_buffer = "";
			next;
		} else {
			$in_stmt = 1;
			next;
		}
		
	}
	close Reader;
	$$script_ref = $output_buffer;
}

sub generate_sql {
	return sprintf("%s%s%s",
								 generate_sql_boilerplate(),
								 generate_probe_status_proc(),
								 generate_procedures());
}

sub jobusage {
	my ($clause) = @_;
	$clause =~ s&\w*?Summary(\.*)&JobUsageRecord$1&g if $clause;
	return $clause;
}

sub generate_procedures {
	my $procedure_code = '';
	foreach my $procedure (sort keys %procedures) {
		$procedure eq 'newProcedure' and next;
		$procedures{$procedure}->{main_where} = "$procedures{$procedure}->{main_where} and"
			if $procedures{$procedure}->{main_where};
		my $jobusage_select = jobusage($procedures{$procedure}->{select_columns});
		my $jobusage_from_tables = jobusage($procedures{$procedure}->{from_tables});
		my $jobusage_main_where = jobusage($procedures{$procedure}->{main_where});
		my $jobusage_group_by = jobusage($procedures{$procedure}->{group_by});
		my $jobusage_order_by = jobusage($procedures{$procedure}->{order_by});
		$procedure_code = sprintf("%s%s",	$procedure_code, <<"EOF");
drop procedure if exists $procedure
||
create procedure $procedure (userName varchar(64), userRole varchar(64),
	fromdate varchar(64), todate varchar(64), format varchar(64),
	resourceType varchar(64) DEFAULT '')
begin

EOF
		$procedure_code = sprintf("%s%s", $procedure_code, <<'EOF');
	select generateResourceTypeClause(resourceType) into @myresourceclause;
	select SystemProplist.cdr into @usereportauthentication from SystemProplist
	where SystemProplist.car = 'use.report.authentication';
	select RolesTable.whereclause into @mywhereclause from RolesTable
		where RolesTable.role = userRole;
	select generateWhereClause(userName,userRole,@mywhereclause)
		into @mywhereclause;
	call parse(userName,@name,@key,@vo);

	set @sql :=
EOF
		$procedure_code = sprintf("%s%s",	$procedure_code, <<"EOF");
		'select $jobusage_select
		from $jobusage_from_tables
		where
EOF
		$procedure_code = "$procedure_code		$jobusage_main_where\n" if $jobusage_main_where;
		$procedure_code = sprintf("%s%s",	$procedure_code, <<'EOF');
		EndTime >= fromdate
		and EndTime <= todate
		@myresourceclause
		@mywhereclause
EOF
		my $group_by = $jobusage_group_by;
		$group_by =~ s/((?:\b[^\.]+\.)?EndTime)/date_format($1,format)/g;
		$procedure_code = "$procedure_code		group by $group_by\n" if $group_by;
		$procedure_code = "$procedure_code		order by $jobusage_order_by"
			if $jobusage_order_by;
		$procedure_code = sprintf("%s%s", $procedure_code, <<'EOF');
';

	if @mywhereclause = '' and datediff(todate,fromdate) > 6 then
		-- Use summary table
		set @sql :=
EOF
		$group_by = $procedures{$procedure}->{group_by};
		$group_by =~ s/((?:\b[^\.]+\.)?EndTime)/date_format($1,format)/g;
		$procedure_code = sprintf("%s%s",	$procedure_code, <<"EOF");
			'select $procedures{$procedure}->{select_columns}
			from $procedures{$procedure}->{from_tables}
			where
EOF
		$procedure_code = "$procedure_code			$procedures{$procedure}->{main_where}\n"
			if $procedures{$procedure}->{main_where};
		$procedure_code = sprintf("%s%s",	$procedure_code, <<'EOF');
			EndTime >= date(fromdate)
			and EndTime <= date(todate)
			@myresourceclause
			@mywhereclause
EOF
		$procedure_code = "$procedure_code			group by $group_by\n" if $group_by;
		$procedure_code = "$procedure_code			order by $procedures{$procedure}->{order_by}"
			if $procedures{$procedure}->{order_by};
		$procedure_code = sprintf("%s%s",	$procedure_code, <<"EOF");
';
	end if;
	insert into trace(pname,userkey,user,role,vo,p1,p2,p3,p4,data)
		values('$procedure',\@key,userName,userRole,\@vo,
		fromdate,todate,format,resourceType,\@sql);
	prepare statement from \@sql;
	execute statement;
	deallocate prepare statement;
end
||
-- call $procedure('GratiaUser','GratiaUser','2006-10-01 00:00:00','2006-10-10 00:00:00','\%y:\%m:\%d:\%H:\%i','Batch')
||
EOF
	}
	return $procedure_code;
}

sub generate_sql_boilerplate {
	return <<'EOF';
delimiter ||
drop table if exists trace
||
CREATE TABLE trace (
  eventtime TIMESTAMP NOT NULL,
	pname varchar(64),
	userkey varchar(64),
	user varchar(64),
	role varchar(64),
	vo varchar(64),
	p1 varchar(64),
	p2 varchar(64),
	p3 varchar(64),
	p4 varchar(64),
	p5 varchar(64),
	p6 varchar(64),
	p7 varchar(64),
	p8 varchar(64),
	p9 varchar(64),
  data TEXT
)
||
drop procedure if exists parse
||
create procedure parse(username varchar(64),out outname varchar(64),
	out outkey varchar(64),out outvo varchar(64))
begin
	set outname = '';
	set outkey = '';
	set outvo = '';
	set @username = username;
	set @index = locate('|',@username);
	if @index > 0 then
		set outname = substring(@username,1,@index - 1);
		set @username = substring(@username,@index + 1);
	end if;
	set @index = locate('|',@username);
	if @index > 0 then
		set outkey = substring(@username,1,@index - 1);
		set outvo = substring(@username,@index + 1);
	else
		set outkey = @username;
	end if;
	insert into trace(p1,p2,p3,p4) values(username,outname,outkey,outvo);
end
||
drop function if exists generateWhereClause
||
create function generateWhereClause(userName varchar(64),userRole varchar(64),
	whereClause varchar(255)) returns varchar(255)
begin
	select SystemProplist.cdr into @usereportauthentication from SystemProplist
		where SystemProplist.car = 'use.report.authentication';
	if userName = 'GratiaGlobalAdmin' or @usereportauthentication = 'false' then
		return '';
	end if;
	if whereClause = 'Everything' then
		return '';
	end if;
	return concat(' and ',whereClause,' ');
end
||
drop function if exists generateResourceTypeClause
||
create function generateResourceTypeClause(resourceType varchar(64))
	returns varchar(255)
begin
	if resourceType = '' or resourceType = NULL then
		return ''
	else
		return concat(
			' and ResourceType = ''',
			resourceType,
			'''');
	end if	
end
||
EOF
}

sub generate_probe_status_proc {
	return <<'EOF';
drop procedure if exists ProbeStatus
||
create procedure ProbeStatus (userName varchar(64),userRole varchar(64),
	fromdate varchar(64),todate varchar(64),format varchar(64))
begin

	declare mywhereclause varchar(255);
	set @myfromdate := fromdate;
	set @mytodate := todate;

	insert into trace(pname,userkey) values('ProbeStatus','step00');
	select SystemProplist.cdr into @usereportauthentication from SystemProplist
		where SystemProplist.car = 'use.report.authentication';
	insert into trace(pname,userkey) values('ProbeStatus','step01');
	select RolesTable.whereclause into @mywhereclause from RolesTable
		where RolesTable.role = userRole;
	insert into trace(pname,userkey) values('ProbeStatus','step02');
	select generateWhereClause(userName,userRole,@mywhereclause)
		into @mywhereclause;
	insert into trace(pname,userkey) values('ProbeStatus','step03');
	call parse(userName,@name,@key,@vo);
	insert into trace(pname,userkey) values('ProbeStatus','step04');

	insert into trace(pname,userkey,user,role,vo,p1,p2)
		values('ProbeStatus',@key,userName,userRole,@vo,fromdate,todate);

	if @mywhereclause = '' then
			insert into trace(pname,userKey) values('ProbeStatus','Got It !!');
			select ProbeName,EndTime as endtime,Njobs as Njobs
				from ProbeStatus
				where
					EndTime >= fromdate and EndTime <= todate
				group by EndTime,ProbeName
				order by EndTime;
	end if;
end
||
-- call ProbeStatus('GratiaGlobalAdmin','GratiaUser','2006-01-01 00:00:00','2006-12-31 00:00:00','ignore');
||
EOF
}


### Local Variables:
### mode: cperl
### End:
