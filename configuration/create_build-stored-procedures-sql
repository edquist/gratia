eval '(exit $?0)' && eval 'exec perl -w -S $0 ${1+"$@"}'
                  && eval 'exec perl -w -S $0 $argv:q'
                  if 0;

use strict;

use Getopt::Long;
use File::Basename;
use Pod::Usage;

my %options = ();

my %mysql_options =
(
 "-v" => undef,
 "--force" => undef,
 "-unbuffered" => undef,
 "--user" => "root",
 "--password" => "",
 "--host" => "localhost",
 "--port" => 3320
);

my @default_procedure_argument_list =
	("userName varchar(64)", "userRole varchar(64)",
	 "fromdate varchar(64)", "todate varchar(64)",
	 "format varchar(64)", "resourceType varchar(64)"
	);

my %procedures =
(
 DailyJobsByFacility => { select_columns => 'CETable.facility_name, ProbeSummary.EndTime as endtime, sum(ProbeSummary.Njobs) as Njobs',
													from_tables => 'CETable,CEProbes,ProbeSummary',
													main_where => 'CEProbes.facility_id = CETable.facility_id and ProbeSummary.ProbeName = CEProbes.probename',
													group_by => 'ProbeSummary.EndTime, CETable.facility_name',
													order_by => 'ProbeSummary.EndTime'
												},
 DailyJobsByProbe => { select_columns => 'ProbeSummary.ProbeName, ProbeSummary.EndTime as endtime, sum(ProbeSummary.Njobs) as Njobs',
											 from_tables => 'ProbeSummary',
											 main_where => '',
											 group_by => 'ProbeSummary.EndTime, ProbeSummary.ProbeName',
											 order_by => 'ProbeSummary.EndTime'
										 },
 DailyJobsByVO => { select_columns => 'VOProbeSummary.VOName,VOProbeSummary.EndTime as endtime,sum(VOProbeSummary.Njobs) as Njobs',
										from_tables => 'VOProbeSummary',
										main_where => '',
										group_by => 'VOProbeSummary.EndTime,VOProbeSummary.VOName',
										order_by => 'VOProbeSummary.EndTime'
									},
 DailyUsageByFacility => { select_columns => 'CETable.facility_name,ProbeSummary.EndTime as endtime,sum(ProbeSummary.WallDuration) as WallDuration',
													 from_tables => 'CETable,CEProbes,ProbeSummary',
													 main_where => 'CEProbes.facility_id = CETable.facility_id and ProbeSummary.ProbeName = CEProbes.probename',
													 group_by => 'ProbeSummary.EndTime,CETable.facility_name',
													 order_by => 'ProbeSummary.EndTime'
												 },
 DailyUsageByProbe => { select_columns => 'ProbeSummary.ProbeName,ProbeSummary.EndTime as endtime,sum(ProbeSummary.WallDuration) as WallDuration',
												from_tables => 'ProbeSummary',
												main_where => '',
												group_by => 'ProbeSummary.EndTime,ProbeSummary.ProbeName',
												order_by => 'ProbeSummary.EndTime'
											},
 JobsByFacility => { select_columns => 'CETable.facility_name,sum(ProbeSummary.Njobs) as Njobs',
										 from_tables => 'CETable,CEProbes,ProbeSummary',
										 main_where => 'CEProbes.facility_id = CETable.facility_id and ProbeSummary.ProbeName = CEProbes.probename',
										 group_by => 'CETable.facility_name',
										 order_by => 'CETable.facility_name'
									 },
 JobsByProbeNoFacility => { select_columns => 'ProbeSummary.ProbeName,sum(ProbeSummary.Njobs) as Njobs',
														from_tables => 'ProbeSummary',
														main_where => '',
														group_by => 'ProbeSummary.ProbeName',
														order_by => 'ProbeSummary.ProbeName'
													},
 UsageByFacility => { select_columns => 'CETable.facility_name,VOProbeSummary.EndTime as endtime,sum(VOProbeSummary.WallDuration) as WallDuration,sum(VOProbeSummary.CpuUserDuration + VOProbeSummary.CpuSystemDuration) as Cpu',
											from_tables => 'CETable,CEProbes,VOProbeSummary',
											main_where => 'CEProbes.facility_id = CETable.facility_id and VOProbeSummary.ProbeName = CEProbes.probename',
											group_by => 'CETable.facility_name',
											order_by => 'CETable.facility_name'
										},
 UsageByProbe => { select_columns => 'ProbeSummary.ProbeName,sum(ProbeSummary.WallDuration) as WallDuration',
									 from_tables => 'ProbeSummary',
									 main_where => '',
									 group_by => 'ProbeSummary.ProbeName',
									 order_by => 'ProbeSummary.ProbeName'
								 },
 DailyUsageBySite => { select_columns => 'ProbeSummary.ProbeName,ProbeSummary.EndTime as endtime,sum(ProbeSummary.WallDuration) as WallDuration,sum(ProbeSummary.CpuUserDuration + ProbeSummary.CpuSystemDuration) as Cpu',
											 from_tables => 'ProbeSummary',
											 main_where => '',
											 group_by => 'ProbeSummary.EndTime,ProbeSummary.ProbeName',
											 order_by => 'ProbeSummary.EndTime,ProbeSummary.ProbeName'
										 },
 UsageBySite => { select_columns => 'ProbeSummary.SiteName,sum(ProbeSummary.WallDuration) as WallDuration',
									from_tables => 'ProbeSummary',
									main_where => '',
									group_by => 'ProbeSummary.SiteName',
									order_by => 'ProbeSummary.SiteName'
								},
 JobsBySite => { select_columns => 'ProbeSummary.SiteName,sum(ProbeSummary.Njobs) as Njobs',
								 from_tables => 'ProbeSummary',
								 main_where => '',
								 group_by => 'ProbeSummary.SiteName',
								 order_by => 'ProbeSummary.SiteName'
							 },
 DailyUsageByVO => { select_columns => 'VOProbeSummary.VOName,VOProbeSummary.EndTime as endtime, sum(VOProbeSummary.WallDuration) as WallDuration,sum(VOProbeSummary.CpuUserDuration + VOProbeSummary.CpuSystemDuration) as Cpu',
										 from_tables => 'VOProbeSummary',
										 main_where => '',
										 group_by => 'VOProbeSummary.EndTime,VOProbeSummary.VOName',
										 order_by => 'VOProbeSummary.EndTime'
									 },
 UsageByVO => { select_columns => 'VOProbeSummary.VOName,sum(VOProbeSummary.WallDuration) as WallDuration,sum(VOProbeSummary.CpuUserDuration + VOProbeSummary.CpuSystemDuration) as Cpu',
								from_tables => 'VOProbeSummary',
								main_where => '',
								group_by => 'VOProbeSummary.VOName',
								order_by => 'VOProbeSummary.VOName'
							},
 JobsByVO => { select_columns => 'VOProbeSummary.VOName,sum(VOProbeSummary.Njobs) as Njobs',
							 from_tables => 'VOProbeSummary',
							 main_where => '',
							 group_by => 'VOProbeSummary.VOName',
							 order_by => 'VOProbeSummary.VOName'
						 },
 JobsByFacilityForVO => { extra_procedure_arguments => [ 'vo varchar(64)' ],
													extra_test_arguments => [ "'Unknown'" ],
													select_columns => 'CETable.facility_name, sum(VOProbeSummary.Njobs) as Njobs',
													from_tables => 'CETable,CEProbes,VOProbeSummary',
													main_where => 'CEProbes.facility_id = CETable.facility_id and VOProbeSummary.ProbeName = CEProbes.probename and VOProbeSummary.VOName = \'\'\', vo, \'\'\'',
													group_by => 'CETable.facility_name',
													order_by => 'CETable.facility_name'
												},
 JobsByUserForVOForFacility => { extra_procedure_arguments => [ 'vo varchar(64)',
																																'facility_name varchar(64)' ],
																 extra_test_arguments => [ "'Unknown'", "'FNAL_FERMIGRID'" ],
																 select_columns => 'VOProbeSummary.CommonName as User, sum(VOProbeSummary.Njobs) as Njobs',
																 from_tables => 'CETable,CEProbes,VOProbeSummary',
																 main_where => 'CETable.facility_name = \'\'\', facility_name, \'\'\' and CEProbes.facility_id = CETable.facility_id and VOProbeSummary.ProbeName = CEProbes.probename and VOProbeSummary.VOName = \'\'\', vo, \'\'\'',
																 group_by => 'User',
																 order_by => 'User'
															 },
 UsageByFacilityForVO => { extra_procedure_arguments => [ 'vo varchar(64)' ],
													 extra_test_arguments => [ "'Unknown'" ],
													 select_columns => 'CETable.facility_name, sum(VOProbeSummary.WallDuration) as WallDuration,sum(VOProbeSummary.CpuUserDuration + VOProbeSummary.CpuSystemDuration) as Cpu',
													 from_tables => 'CETable,CEProbes,VOProbeSummary',
													 main_where => 'CEProbes.facility_id = CETable.facility_id and VOProbeSummary.ProbeName = CEProbes.probename and VOProbeSummary.VOName = \'\'\', vo, \'\'\'',
													 group_by => 'CETable.facility_name',
													 order_by => 'CETable.facility_name'
												 },
 UsageByUserForVOForFacility => { extra_procedure_arguments => [ 'vo varchar(64)',
																																 'facility_name varchar(64)' ],
																	extra_test_arguments => [ "'Unknown'", "'FNAL_FERMIGRID'" ],
																	select_columns => 'VOProbeSummary.CommonName as User, sum(VOProbeSummary.WallDuration) as WallDuration,sum(VOProbeSummary.CpuUserDuration + VOProbeSummary.CpuSystemDuration) as Cpu',
																	from_tables => 'CETable,CEProbes,VOProbeSummary',
																	main_where => 'CETable.facility_name = \'\'\', facility_name, \'\'\' and CEProbes.facility_id = CETable.facility_id and VOProbeSummary.ProbeName = CEProbes.probename and VOProbeSummary.VOName = \'\'\', vo, \'\'\'',
																	group_by => 'User',
																	order_by => 'User'
																},
 WeeklyUsageByVO => { extra_procedure_arguments => [ 'vos varchar(128)',
																										 'voseltype varchar(8)' ],
											select_columns => 'VOProbeSummary.VOName,date_format(VOProbeSummary.EndTime, \'\'\', format, \'\'\') as endtime, sum(VOProbeSummary.WallDuration) as WallDuration,sum(VOProbeSummary.CpuUserDuration + VOProbeSummary.CpuSystemDuration) as Cpu',
											from_tables => 'VOProbeSummary',
											main_where => 'VOProbeSummary.VOName \', voseltype, vos, \'',
											group_by => 'VOProbeSummary.EndTime,VOProbeSummary.VOName',
											order_by => 'VOProbeSummary.EndTime'
										},
 WeeklyJobsByVO => { extra_procedure_arguments => [ 'vos varchar(128)',
																										'voseltype varchar(8)' ],
										 select_columns => 'VOProbeSummary.VOName,date_format(VOProbeSummary.EndTime, \'\'\', format, \'\'\') as endtime,sum(VOProbeSummary.Njobs) as Njobs',
										 from_tables => 'VOProbeSummary',
										 main_where => 'VOProbeSummary.VOName \', voseltype, vos, \'',
										 group_by => 'VOProbeSummary.EndTime,VOProbeSummary.VOName',
										 order_by => 'VOProbeSummary.EndTime'
									 },
 JobsBySiteByVO =>	{ select_columns => 'CETable.facility_name as sitename, sum(VOProbeSummary.Njobs) as Njobs, VOProbeSummary.VOName',
							from_tables => 'CETable,CEProbes,VOProbeSummary',
							main_where => 'CEProbes.facility_id = CETable.facility_id and VOProbeSummary.ProbeName = CEProbes.probename',
							group_by => 'sitename, VOProbeSummary.VOName',
							order_by => 'sitename, VOProbeSummary.VOName'
												},
 UsageBySiteByVO =>	{ select_columns => 'CETable.facility_name as sitename, sum(VOProbeSummary.WallDuration) as WallDuration, sum(VOProbeSummary.CpuUserDuration + VOProbeSummary.CpuSystemDuration) as Cpu, VOProbeSummary.VOName',
							from_tables => 'CETable,CEProbes,VOProbeSummary',
							main_where => 'CEProbes.facility_id = CETable.facility_id and VOProbeSummary.ProbeName = CEProbes.probename',
							group_by => 'sitename, VOProbeSummary.VOName',
							order_by => 'sitename, VOProbeSummary.VOName'
												}, 
 newProcedure => { select_columns => '',
									 from_tables => '',
									 main_where => '',
									 group_by => '',
									 order_by => ''
								 }
);

my @databases = qw(gratia gratia_itb gratia_psacct gratia_qcd gratia_osg_daily);

Getopt::Long::Configure(qw(no_ignore_case bundling require_order));

GetOptions(\%options, "debug|d", "trace|t", "help|h|\?") or pod2usage(-exitval => 2);

my @procedure_list = ();
if (scalar @ARGV) {
	@procedure_list = @ARGV;
}

$options{debug} = 1;
# $options{trace} = 1;

if ($options{debug}) {
	my $sql_script = generate_sql(@procedure_list);
	print $sql_script;
	exit 0;
} else {
	#mysql_connect();
	foreach my $database (@databases) {
		# set database $database
		# execute generate_sql();
	}
}

1;

sub process_trace_directives {
	my ($script_ref,$trace_opt) = @_;
	return if $trace_opt;					# trace inserts stay in
	my $tmp_file = `mktemp \${TMPDIR:-/tmp}/create_build.XXXXXXXXXX`;
	chomp $tmp_file;
	$tmp_file or die "Unable to get temporary file name";
	open(TMPFILE, ">$tmp_file") or die "Unable to open temporary file $tmp_file for write";
	print TMPFILE $$script_ref;
	close TMPFILE;
	open(TMPFILE, "<$tmp_file") or die "Unable to open temporary file $tmp_file for read";
	my $input_buffer = "";
	my $in_stmt;
	my $output_buffer;
	while (<TMPFILE>) {
		$input_buffer = "$input_buffer$_";
		chomp;
		if ((not $in_stmt) and m&^\s*(?:#|--|$)&) {
			$output_buffer = "$output_buffer$input_buffer";
			$input_buffer = "";
			next;
		} elsif (m&(?:;|\|\|)\s*(?:#.*)?$&
						 or m&\b(?:then|else)\s*(?:#.*)?$&i) {
			if (not ($input_buffer =~ m&insert\s*into\s*trace&m)) {
				$output_buffer = "$output_buffer$input_buffer";
			}
			undef $in_stmt;
			$input_buffer = "";
			next;
		} else {
			$in_stmt = 1;
			next;
		}
	}
	close TMPFILE;
	$$script_ref = $output_buffer;
}

sub generate_sql {
	if (scalar @_) {
		return sprintf("%s%s%s",
									 generate_frontmatter(),
									 generate_procedures(@_),
									 generate_endmatter());
	} else {
		my $infrastructure_sql =
			sprintf("%s%s%s",
							generate_frontmatter(),
							generate_sql_boilerplate(),
							generate_probe_status_proc());
		process_trace_directives(\$infrastructure_sql, $options{trace});

		return sprintf("%s%s%s",
									 $infrastructure_sql,
									 generate_procedures(),
									 generate_endmatter());
	}
}

sub jobusage {
	my ($clause) = @_;
	$clause =~ s&\w*?Summary(\.*)&JobUsageRecord$1&g if $clause;
	return $clause;
}

sub generate_procedures {
	my $procedure_code = '';
	my @procedure_list = @_;
	@procedure_list = sort keys %procedures unless (scalar @procedure_list);
	foreach my $procedure (@procedure_list) {
		$procedure eq 'newProcedure' and next;
		$procedures{$procedure}->{main_where} = "$procedures{$procedure}->{main_where} and"
			if $procedures{$procedure}->{main_where};
		my $jobusage_select = jobusage($procedures{$procedure}->{select_columns});
		my $jobusage_from_tables = jobusage($procedures{$procedure}->{from_tables});
		my $jobusage_main_where = jobusage($procedures{$procedure}->{main_where});
		my $jobusage_group_by = jobusage($procedures{$procedure}->{group_by});
		my $jobusage_order_by = jobusage($procedures{$procedure}->{order_by});
		$procedure_code = sprintf("%s\ndrop procedure if exists $procedure
||
create procedure $procedure (%s)
begin

", $procedure_code, join(", ", @default_procedure_argument_list,
												 (exists $procedures{$procedure}->{extra_procedure_arguments})?
												 @{$procedures{$procedure}->{extra_procedure_arguments}}:
												 ()));
		$procedure_code = sprintf("%s%s", $procedure_code, <<'EOF');
	select generateResourceTypeClause(resourceType) into @myresourceclause;
	select SystemProplist.cdr into @usereportauthentication from SystemProplist
	where SystemProplist.car = 'use.report.authentication';
	select RolesTable.whereclause into @mywhereclause from RolesTable
		where RolesTable.role = userRole;
	select generateWhereClause(userName,userRole,@mywhereclause)
		into @mywhereclause;
	call parse(userName,@name,@key,@vo);
EOF

		if (exists $procedures{$procedure}->{extra_procedure_arguments} and
				grep /voseltype/, @{$procedures{$procedure}->{extra_procedure_arguments}})
			{
			$procedure_code = sprintf("%s%s",	$procedure_code, <<'EOF');
	-- Inelegant kludge to get around trouble .jsp has handling
	-- arguments with embedded spaces; this will be unnecessary when
	-- the view code gets rewritten.
	if voseltype = 'NOT' then
		set voseltype := 'NOT IN';
	end if;
EOF
		 }

		$procedure_code = sprintf("%s%s",	$procedure_code, <<"EOF");

	set \@sql :=
           concat_ws('', 'select $jobusage_select',
                     ' from $jobusage_from_tables',
                     ' where',
EOF
		$procedure_code = "$procedure_code                     ' $jobusage_main_where',\n" if $jobusage_main_where;
		$procedure_code = sprintf("%s%s",	$procedure_code, <<'EOF');
                     ' EndTime >= ''', fromdate, ''''
                     ' and EndTime <= ''', todate, ''''
                     ' ', @myresourceclause,
                     ' ', @mywhereclause
EOF
		my $group_by = $jobusage_group_by;
		$group_by =~ s/((?:\b[^\.]+\.)?EndTime)/date_format($1,''', format, ''')/g;
		$procedure_code = "$procedure_code                     , ' group by $group_by'\n" if $group_by;
		$procedure_code = "$procedure_code                     , ' order by $jobusage_order_by'\n"
			if $jobusage_order_by;
		$procedure_code = "$procedure_code                    );\n\n";

		$procedure_code = sprintf("%s%s", $procedure_code, <<'EOF');
    if ( @mywhereclause = '' or @mywhereclause is NULL ) and datediff(todate,fromdate) > 6 then
		-- Use summary table
		set @sql :=
EOF
		$group_by = $procedures{$procedure}->{group_by};
		$group_by =~ s/((?:\b[^\.]+\.)?EndTime)/date_format($1,''', format, ''')/g;
		$procedure_code = sprintf("%s%s",	$procedure_code, <<"EOF");
           concat_ws('', 'select $procedures{$procedure}->{select_columns}',
                     ' from $procedures{$procedure}->{from_tables}',
                     ' where',
EOF
		$procedure_code = "$procedure_code                     ' $procedures{$procedure}->{main_where}',\n"
			if $procedures{$procedure}->{main_where};
		$procedure_code = sprintf("%s%s",	$procedure_code, <<'EOF');
                     ' EndTime >= date(''', fromdate, ''')',
                     ' and EndTime <= date(''', todate, ''')',
                     ' ', @myresourceclause,
                     ' ', @mywhereclause
EOF
		$procedure_code = "${procedure_code}                     , ' group by $group_by'\n"
			if $group_by;
		$procedure_code = "${procedure_code}                     , ' order by $procedures{$procedure}->{order_by}'\n"
			if $procedures{$procedure}->{order_by};
		$procedure_code = sprintf("%s%s",	$procedure_code, <<"EOF");
                 );
	end if;
	insert into trace(pname,userkey,user,role,vo,p1,p2,p3,p4,data)
		values('$procedure',\@key,userName,userRole,\@vo,
		fromdate,todate,format,resourceType,\@sql);
	prepare statement from \@sql;
	execute statement;
	deallocate prepare statement;
end
||
EOF
		my $date_format = ($procedure =~ m&daily&i)?'%y:%m:%d':'%y:%m:%d:%H:%i';
		my $extra_args = (exists $procedures{$procedure}->{extra_test_arguments} and
										 scalar @{$procedures{$procedure}->{extra_test_arguments}})?
			sprintf(", %s", join(", ", @{$procedures{$procedure}->{extra_test_arguments}})):'';
		$procedure_code = sprintf("%s%s",	$procedure_code, <<"EOF");
-- call $procedure('GratiaUser','GratiaUser','2007-02-01 00:00:00','2007-02-10 00:00:00','$date_format','Batch'$extra_args)
-- ||
-- call $procedure('GratiaUser','GratiaUser','2007-02-01 00:00:00','2007-02-10 00:00:00','$date_format',''$extra_args)
-- ||
-- call $procedure('GratiaUser','GratiaUser','2007-02-01 00:00:00','2007-02-04 00:00:00','$date_format','Batch'$extra_args)
-- ||
-- call $procedure('GratiaUser','GratiaUser','2007-02-01 00:00:00','2007-02-04 00:00:00','$date_format',''$extra_args)
-- ||
EOF
	}
	return $procedure_code;
}

sub generate_sql_boilerplate {
	return <<'EOF';
drop table if exists trace
||
CREATE TABLE trace (
  eventtime TIMESTAMP NOT NULL,
	pname varchar(64),
	userkey varchar(64),
	user varchar(64),
	role varchar(64),
	vo varchar(64),
	p1 varchar(64),
	p2 varchar(64),
	p3 varchar(64),
	p4 varchar(64),
	p5 varchar(64),
	p6 varchar(64),
	p7 varchar(64),
	p8 varchar(64),
	p9 varchar(64),
  data TEXT
)
||
drop procedure if exists parse
||
create procedure parse(username varchar(64),out outname varchar(64),
	out outkey varchar(64),out outvo varchar(64))
begin
	set outname = '';
	set outkey = '';
	set outvo = '';
	set @username = username;
	set @index = locate('|',@username);
	if @index > 0 then
		set outname = substring(@username,1,@index - 1);
		set @username = substring(@username,@index + 1);
	end if;
	set @index = locate('|',@username);
	if @index > 0 then
		set outkey = substring(@username,1,@index - 1);
		set outvo = substring(@username,@index + 1);
	else
		set outkey = @username;
	end if;
	insert into trace(pname,p1,user,userkey,vo) values('parse',username,outname,outkey,outvo);
end
||
drop function if exists generateWhereClause
||
create function generateWhereClause(userName varchar(64),userRole varchar(64),
	whereClause varchar(255)) returns varchar(255)
begin
	select SystemProplist.cdr into @usereportauthentication from SystemProplist
		where SystemProplist.car = 'use.report.authentication';
	if userName = 'GratiaGlobalAdmin' or @usereportauthentication = 'false' then
		return '';
	end if;
	if whereClause = 'Everything' then
		return '';
	end if;
	return concat(' and ',whereClause,' ');
end
||
drop function if exists generateResourceTypeClause
||
create function generateResourceTypeClause(resourceType varchar(64))
	returns varchar(255)
begin
	if resourceType = '' or resourceType = NULL then
		return '';
	else
		return concat(
			' and ResourceType = ''',
			resourceType,
			'''');
	end if;
end
||
EOF
}

sub generate_probe_status_proc {
	return <<'EOF';
drop procedure if exists ProbeStatus
||
create procedure ProbeStatus (userName varchar(64),userRole varchar(64),
	fromdate varchar(64),todate varchar(64),format varchar(64))
begin

	declare mywhereclause varchar(255);
	set @myfromdate := fromdate;
	set @mytodate := todate;

	insert into trace(pname,userkey) values('ProbeStatus','step00');
	select SystemProplist.cdr into @usereportauthentication from SystemProplist
		where SystemProplist.car = 'use.report.authentication';
	insert into trace(pname,userkey) values('ProbeStatus','step01');
	select RolesTable.whereclause into @mywhereclause from RolesTable
		where RolesTable.role = userRole;
	insert into trace(pname,userkey) values('ProbeStatus','step02');
	select generateWhereClause(userName,userRole,@mywhereclause)
		into @mywhereclause;
	insert into trace(pname,userkey) values('ProbeStatus','step03');
	call parse(userName,@name,@key,@vo);
	insert into trace(pname,userkey) values('ProbeStatus','step04');

	insert into trace(pname,userkey,user,role,vo,p1,p2)
		values('ProbeStatus',@key,userName,userRole,@vo,fromdate,todate);

	if @mywhereclause = '' then
			insert into trace(pname,userKey) values('ProbeStatus','Got It !!');
			select ProbeName,EndTime as endtime,Njobs as Njobs
				from ProbeStatus
				where
					EndTime >= fromdate and EndTime <= todate
				group by EndTime,ProbeName
				order by EndTime;
	end if;
end
||
-- call ProbeStatus('GratiaGlobalAdmin','GratiaUser','2006-01-01 00:00:00','2007-12-31 00:00:00','ignore');
-- ||
EOF
}

sub generate_frontmatter {
return << 'EOF';
delimiter ||

EOF
}

sub generate_endmatter {
return << 'EOF';


-- Local Variables:
-- mode: sql
-- eval: (sql-set-product 'mysql)
-- End:
EOF
}
 # Page marker to avoid confusion over Local Variables sections.
### Local Variables:
### mode: cperl
### End:
