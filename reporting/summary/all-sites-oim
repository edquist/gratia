eval '(exit $?0)' && eval 'exec perl -w -S $0 ${1+"$@"}'
                  && eval 'exec perl -w -S $0 $argv:q'
                  if 0;

use strict;

use Getopt::Long;
use File::Basename;

Getopt::Long::Configure(qw(no_ignore_case bundling require_order));

use vars qw($script_top_dir);
BEGIN {
  # Make a spirited attempt to find where our libraries, etc are.
  if (-l $0) {
    $script_top_dir = dirname(readlink($0));
  } else {
    $script_top_dir = dirname $0;
  }
}

use lib "$script_top_dir";

use FileHandle;

use GratiaReporting::Data;
use GratiaReporting::Reporter;

sub expandSites(\@);

my $options = {};
my $osg_users_script = "$script_top_dir/osg-users";
my @test_addresses = ( 'Chris Green <chris.h.green@gmail.com>' );

GetOptions($options,
           "debug|d",
           "verbose|v",
           "monthly|M",
           "weekly|W",
           "yearly|Y",
           "test|t",
           "data-source|D=s@",
           "site-name|s=s@",
           "extra-mail|e=s@",
           "exclusive-mail|m=s@",
           "grid-type|g=s@",
           "service=s@",
           "for-user|u=s@") or die $@;

my $reporter = new GratiaReporting::Reporter( debug => $options->{debug},
                                              verbose => $options->{verbose},
                                              test => $options->{test}
                                            );

my $wanted_sites = {};
foreach my $site (@{$options->{"site-name"}}) {
  $wanted_sites->{$site} = 1;
}

my $wanted_grid_types = {};
foreach my $grid_type (@{$options->{"grid-type"}}) {
  $wanted_grid_types = 1;
}
unless (scalar keys %$wanted_grid_types) { # Default
  $wanted_grid_types->{OSG} = 1;
}

my $wanted_services = {};
foreach my $service (@{$options->{service}}) {
  $wanted_services->{$service} = 1;
}
unless (scalar keys %$wanted_services) { # Defaults
  $wanted_services->{CE} = 1;
  $wanted_services->{"Hidden CE"} = 1;
  $wanted_services->{"Hidden CE/SE"} = 1;
}

my $all_sites = not scalar keys %{$wanted_sites};

# Parse reporting data from all sources
my $reporting_data =
  new GratiaReporting::Data( verbose => $options->{verbose},
                             data_source => $options->{"data-source"}
                           );

# Construct the command line(s) and invoke.
my @base_command = ("$osg_users_script",
                    "-s",
                    "-S",
                    "--aux-db-type=none",
                    ($options->{"data-source"})?(map { ("-D", $_) } @{$options->{"data-source"}}):());
my @base_mail_opts = ();
if ($options->{"exclusive-mail"}) { # Short-circuit people list.
  my @command = @base_command;
  my @mail_opts = @base_mail_opts;
  if ($options->{monthly}) {
    push @command, "-t", "month";
  } elsif ($options->{yearly}) {
    push @command, "-t", "year";
  }
  push @command, map { ("--site", $_) } expandSites(@{$options->{"site-name"}})
    if $options->{"site-name"};
  push @mail_opts, map { ("-m", $_) } @{$options->{"exclusive-mail"}};
  $reporter->invoke(\@command, \@mail_opts);
} else { # Standard -- take main lead from .dat files and OIM.
  if ($options->{monthly}) {
    push @base_command, "-t", "month";
  } elsif ($options->{yearly}) {
    push @base_command, "-t", "year";
  }
  $options->{"extra-mail"} = [] unless $options->{"extra-mail"};
  push @{$options->{"extra-mail"}},
    map { (exists $people_data->{$_}->{all_reports}->{site} and
           $people_data->{$_}->{all_reports}->{site})?($_):()} keys %{$people_data};
  push @base_mail_opts, map { ("-m", $_) } @{$options->{"extra-mail"}} if $options->{"extra-mail"};
  my @user_list;
  if ($options->{"for-user"}) { # mini-short-circuit
    @user_list = map {
      if (exists $people_data->{$_}) {
        ($_)
      } else {
        print STDERR "WARNING: specified user $_ not known -- ignoring.\n";
        ()
      }
    } @{$options->{"for-user"}};
  } else {
    @user_list = keys %$people_data;
  }
  foreach my $primary_email (sort @user_list) {
    my @command = @base_command;
    my @mail_opts = @base_mail_opts;
    my $person = $people_data->{$primary_email};
    if ($person->{all_reports} and $person->{all_reports}->{site}) {
    }
    if ($options->{test}) {
      push @mail_opts, map { ("-m", $_) } @test_addresses
        if scalar @test_addresses;
    } else {
      push @mail_opts, "-m", "$person->{contact_string}";
    }
    my @wanted_sites = map { ("--site-name", $_) }
      expandSites(@{$person->{sites}}) if $person->{sites};
    next unless @wanted_sites and scalar @wanted_sites;
    push @command, @wanted_sites;
    if ($person->{site_vos}) {
      foreach my $vo (sort map { lc $_ } @{$person->{site_vos}}) {
        my @looped_cmd = @command;
        push @looped_cmd, "-v", $vo;
        $reporter->invoke(\@looped_cmd, \@mail_opts);
      }
    } else {
      $reporter->invoke(\@command, \@mail_opts);
    }
  }
}

1;

sub expandSites(\@) {
  my $siteList = shift;
  my %u_sites = ();
  foreach my $site (@$siteList) {
    if ($site =~ m&^all$&i) {
      map { $u_sites{$_} = 1 } keys %$site_data;
    } else {
      next unless ($site and
                   $site_data->{$site} and
                   ($all_sites or $wanted_sites->{$site})); # Want this site?
      next if ($site_data->{$site}->{grid_type} and not
               $wanted_grid_types->{$site_data->{$site}->{grid_type}}); # Want this grid type?
      next if ($site and
               $site_data->{$site} and
               exists $site_data->{$site}->{services} and
               not grep { $wanted_services->{$_} } keys %{$site_data->{$site}->{services}});
      $u_sites{$site} = 1;
    }
  }
  return sort keys %u_sites;
}

__END__

### Local Variables:
### mode: cperl
### End:
